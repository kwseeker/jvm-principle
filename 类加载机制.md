# JVM类加载机制

类加载机制将Class文件加载到内存，并对数据进行校验、转换解析和初始化，
最终形成被虚拟机直接使用的Java类型。

在Java 里面连接是在程序运行期间完成的，而不是像C/C++那样在编译期间进行连接，
因此当需要小改线上项目时，我们可以替换class文件而不是重新编译打包；
还可以在运行时才指定要使用的接口实现类；
还可以使用Java类加载器或者自定义的类加载器，从网络或流加载程序代码模块（如Applet和JSP）。

## 要研究的几个问题（看开源代码经常遇到）

### 1 从一个实例代码看JVM的加载流程

#### 类的生命周期

1）加载

a) 通过类的全限定名来获取定义此类的二进制字节流（class）；  
    这个二进制流并不一定要从class文件获取，还可以从网络获取(Applet)，从zip/Jar/War/Ear获取，
    运行时计算生成（动态代理），从其他文件生成（JSP）等。  
b) 将字节流所代表的静态存储结构转化为方法区的运行时数据结构；  
c) 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。  

数组类的加载不是通过类加载器而是JVM直接创建。

加载阶段完成后虚拟机外部二进制字节流就按照虚拟机所需的格式存储在方法区之中，
方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。
然后在内存中实例化一个java.lang.Class类对象，这个对象将作为程序访问方法区中这些类型数据的
外部接口。

2）验证

为了保证虚拟机的安全。

a) 文件格式验证  
b) 元数据验证  
c) 字节码验证  
d) 符号引用验证  

3）准备

为类变量分配内存并设置变量初始值的阶段。只是分配类的静态变量。类的实例变量在类实例化的时候
随对象一起分配在Java堆中。
```
//准备阶段只将值设置为零值，在初始化阶段才将值设置为123
//因为准备阶段还未执行任何方法，将值设置为123的putstatic指令是在类构造器<clinit>()方法中
//而类构造方法在初始化时执行。
public static int value = 123；
//下面这种写法在准备阶段直接将值设置为123
//编译时将为value生成ConstantValue属性，在准备阶段虚拟机根据这个属性将value赋值为123
public static final int value = 123；
```
上面说的编译又是在哪个阶段？  
加载之前，通过编译生成class文件。

4）解析(顺序不固定)

5）初始化  

静态块和静态成员初始化都是在类加载过程中的初始化阶段完成的。

如果类还未初始化需要初始化的情况（注意区分类的初始化和对象的初始化）：

+ 遇到new、getstatic、putstatic、invokestatic字节码指令的时候  
    即new()实例化对象、读取或者设置一个静态字段（编译期就把结果放入常量池的静态字段除外）、
    调用一个静态方法。
+ 使用Reflect方法对类进行反射调用的时候
+ 初始化子类而父类还未初始化的时候
+ 虚拟机启动时主类（带main方法的类）会被初始化
+ 使用动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、
REF_putStatic、REF_invokeStatic的方法句柄对应的类没有初始化则需要先触发初始化

6）使用(顺序不固定)

7）卸载

疑问：
1）static成员是不是都是属于类对象（Class）的？

#### 类加载器

在类生命周期的加载阶段会执行，但是功能不限于类加载阶段。

+ 加载器类型

    - 启动类加载器  
        由C++实现，加载 <JAVA_HOME>/lib 或 -Xbootclasspath 参数指定路径。
        
    - 其他继承java.lang.ClassLoader的类加载器
    
        * 拓展类加载器（ExtClassLoader）
        
            负责加载<JAVA_HOME>/lib/ext 或 java.ext.dirs 系统变量指定的路径中的所有类库。  
            开发者可以直接使用。
            
        * 应用程序类加载器（AppClassLoader）
            
            是ClassLoader getSystemClassLoader()方法的返回值，所以一般称其为系统类加载器。  
            负责加载用户类路径（classpath）上指定的类。  
            开发者可以直接使用。  
            如果应用程序中用户没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
            
        * 自定义类加载器
    
+ 双亲委派模型

    实现代码 java.lang.ClassLoader的loadClass()。

    除了启动类加载器，其他任何类加载器都有自己的父类加载器。  
    类加载器之间的父子关系不是以继承关系实现，而是使用组合关系来复用父加载器的代码。  
    所以关系如下：UserClassLoader（AppClassLoader（ExtClassLoader（BootstrapClassLoader）））  
    
    工作机制：一个类加载其收到类加载请求，首先不会自己去尝试加载这个类，而是把请求委派给父类加载器完成；
    每一个层次的类最后都是传到BootstrapClassLoader加载，如果父加载器反馈自己无法加载（搜索范围无法找到所需类），
    则交还子类加载器去加载。  
    这种工作机制确保了同名类（全路径都相同）的加载优先顺序，如rt.jar中的java.lang.Object总是优先于
    用户定义java.lang.Object的加载，用户自定义的java.lang.Object不会被加载。
    
    ```
    protected Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {
        synchronized(this.getClassLoadingLock(var1)) {
            //1) 判断类是否已经被加载过
            Class var4 = this.findLoadedClass(var1);
            if (var4 == null) {
                long var5 = System.nanoTime();
                try {
                    //2）是否有父类加载器
                    if (this.parent != null) {
                        //交给父类加载器
                        var4 = this.parent.loadClass(var1, false);
                    } else {
                        //自己就是BootstrapClassLoader，执行加载
                        var4 = this.findBootstrapClassOrNull(var1);
                    }
                } catch (ClassNotFoundException var10) {
                    ;
                }
       
                if (var4 == null) {
                    long var7 = System.nanoTime();
                    //3）加载失败的话调用自身的findClass方法来进行加载
                    var4 = this.findClass(var1);
                    PerfCounter.getParentDelegationTime().addTime(var7 - var5);
                    PerfCounter.getFindClassTime().addElapsedTimeFrom(var7);
                    PerfCounter.getFindClasses().increment();
                }
            }
            if (var2) {
                this.resolveClass(var4);
            }
            return var4;
        }
    }
    ```

+ 破坏双亲委派模型

    1）看到前面的分析直到双亲委派的逻辑实现就是在loadClass()方法中，所以可以通过自定义
    类加载器重写这个方法来破坏双亲委派规则。  
    不建议loadClass()实现使用当前类加载器加载类，为了支持这种需求，JDK提供了findClass()方法使用当前类加载器加载新的类。  
    
    2）后来为了解决加载接口在Java标准库定义实现在第三方库的类的加载（如众多SPI接口实现库，因为不在java标准库/lib
    下面启动类加载器是肯定无法加载的），引入了一个不太优雅的设计：线程上下文加载器。这个加载器可以
    通过java.lang.Thread的setContextClassLoader()方法进行设置类加载器，
    如果未设置则先看看能否从父线程继承一个，全局都没有设置过的话就默认使用应用类加载器。
    
    线程上下文加载SPI代码的原理
    
    父类加载器逆向请求子类加载器完成类加载的动作。
    JDBC4.0之前没有SPI拓展机制，需要使用Class.forName()加载实现类。
    JDBC4.0之后拓展了SPI机制，就不需要Class.forName()加载了，因为通过SPI机制可以获取需要加载的
    接口实现类，然后通过DriverManager调用线程上下文类加载器加载接口实现类。
    
    以JDBC Driver加载为例：  
    加载DriverManager时会执行DriverManage的静态块，就会执行loadInitialDrivers()，
    然后判断jdbc.drivers指定的驱动实现类是否已经加载，没有加载的话，通过ServiceLoader及
    线程上下文遍历加载。
    ```
    private static void loadInitialDrivers() {
        String drivers;
        //1) 这里查看driver实现类是否已经被加载
        try {
            drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
                public String run() {
                    return System.getProperty("jdbc.drivers");
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();
                
                try{
                    while(driversIterator.hasNext()) {
                        //2) 这里是实际加载的操作入口
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });

        println("DriverManager.initialize: jdbc.drivers = " + drivers);
        
        if (drivers == null || drivers.equals("")) {
            return;
        }
        String[] driversList = drivers.split(":");
        println("number of Drivers:" + driversList.length);
        for (String aDriver : driversList) {
            try {
                println("DriverManager.Initialize: loading " + aDriver);
                Class.forName(aDriver, true,
                        ClassLoader.getSystemClassLoader());
            } catch (Exception ex) {
                println("DriverManager.Initialize: load failed: " + ex);
            }
        }
    }
    
    public static <S> ServiceLoader<S> load(Class<S> service) {
        //获取线程上下文加载器，自己或父类未设置的话，默认为AppClassLoader
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
    
    //driversIterator.next()里面其实也是Class.forName()
    private S nextService() {
        if (!hasNextService())
            throw new NoSuchElementException();
        String cn = nextName;
        nextName = null;
        Class<?> c = null;
        try {
            //这里就是真正加载接口实现类的地方
            c = Class.forName(cn, false, loader);
        } catch (ClassNotFoundException x) {
            fail(service,
                 "Provider " + cn + " not found");
        }
        if (!service.isAssignableFrom(c)) {
            fail(service,
                 "Provider " + cn  + " not a subtype");
        }
        try {
            S p = service.cast(c.newInstance());
            providers.put(cn, p);
            return p;
        } catch (Throwable x) {
            fail(service,
                 "Provider " + cn + " could not be instantiated",
                 x);
        }
        throw new Error();          // This cannot happen
    }
    ```
  
    3）还有一种破坏双亲委派模型的情况：热加载，为了不重启程序而动态加载一些模块。
    
    可以参考OSGI实现模块化部署的原理。里面提供了另一套加载流程的规则。 
     
疑问

1）除了启动类加载器，其他类加载器应该也是类，那么它们是被怎么加载的？

### 2 Applet和SPI是怎么借助类加载机制实现的？

SPI在Java中很常见，经常在Java核心库看到一些只有方法定义没有实现的Interface。
而这些接口实现则在第三方的库中。如JDBC、Tomcat、JNDI等等。

### 3 为什么需要通过线程上下文加载器来完成SPI调用外部实现？

### 4 线程上下文加载器与双亲委派模型的区别？如何逆向使用类加载器的？

### 5 热部署的实现？(参考：kwseeker/java_base)

## 面试问题

### 1 类加载器具体是个什么东西？有哪些种类？

### 2 类加载器与类分别是怎么判断是否"相同"的？

### 3 双亲委派模型

### 4 如何自定义类加载器？为何要自定义类加载器？

## 注：

1）系统属性是从哪里来的？如JDBC：System.getProperties("jdbc.drivers");

2）查看加载流程 -verbose:class