# JVM对象创建＆内存分配

目标：

+ JVM对象创建详细流程
+ 对象头与指针压缩
+ 对象内存分配详情
+ 逃逸分析＆栈上分配＆标量替换



## 流程图

流程参考java_exec_process.drawio 流程图。



## 类加载检查

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个
符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。



## 分配内存

对象所需内存的大小在类加载完成后便可完全确定。

### 对象的内存结构

Java对象的表示模型叫做“OOP-Klass”二分模型。包括两部分:

+ OOP，即Ordinary Object Point，普通对象指针。表示对象的实例信息。

  OOP，这个应该不只是指对象头中的类型指针（猜测，估计指的是所有对象指针）；如果系统是32G内存以下的，默认开启对象指针压缩，4个字节。

+ Klass，即Java类的C++对等体，用来描述Java类，**包含了元数据和方法信息**等，在类加载中生成存储在**方法区**。

> **这个OOP到底是什么？**上面只是猜测，查下资料，最好能看看HotSpot源码。发现指针压缩不仅仅发生在对象头的类型指针，还发生在实例数据中的对象指针上。
>
> **Klass和Class实例对象又是什么关系？**
>
> JVM通过对象头的类型指针获取Klass元数据信息；Class表示正在运行的Java应用程序中的类和接口，Class是Java提供给用户访问Klass元数据信息的工具。
>
> **对象指针压缩**：
>
> 使用压缩算法将64位地址压缩为32位地址，可以减少对象内存占用，以及数据传输时带宽占用，减轻GC压力；堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间；堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，所以堆内存不要大于32G为好。

Java对象内存结构分为下面三部分：

![](../imgs/Java对象的内存结构HotSpot.png)

Markword: 32位系统占４字节，64位系统占用８字节。

类型指针(Klass Pointer)：开启压缩占4字节，关闭压缩占8字节。

> + **字节对齐**（8字节对齐）
>
>   因为底层硬件平台会要求访问时对齐（减少寻址指令周期），从而维护访问性能和正确性，这就希望字段按照大小对齐。
>
>   64位HotSpot VM每次读取数据的最小单位是**8字节**，因此对象大小必须保持8字节的整数倍，不足则填充。
>
>    JVM对其内部5中静态类型变量，oop、double、word、short和byte都有内存对齐的规则，oop引用类型按4字节对齐；double按8字节对齐；word按4字节；short按2字节，最后byte类型按1字节对齐。
>
> + **字段重排**
>
>   但是因为对齐可能会增加内存间隙（浪费内存），通过字段重排减少内存间隙；JVM 中对齐字段的顺序是 `8->4->2->1`，就是先放大的字段，再放小的字段。当8字节对齐的字段压紧后留下的空隙可以使用一个或几个更小的字段来填充。
>
>   字节对齐自然就是确保内存地址能够被其类型字节宽度所整除，JVM为了优化内存空间利用率，采用了上述的字段重排方式，将相同类型的字段组合在一起，减少一些补白操作，提升了整个空间利用率。
>
>   （注：源于网络，翻了几本书也没找到详细解释的）

### 分配内存的方法

+ 指针碰撞（Bump the Pointer，默认使用方法）
+ 空闲列表（Free List）

择哪种分配方式由Java堆是否规整决定， 而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact） 的能力决定。 因此， 当使用Serial、 ParNew等带压缩整理过程的收集器时， 系统采用的分配算法是指针碰撞， 既简单又高效； 而当使用CMS这种基于清除（Sweep） 算法的收集器时， 理论上就只能采用较为复杂的空闲列表来分配内存。

**内存分配的并发问题解决方案：**

场景：在并发情况下也并不是线程安全的， 可能出现正在给对象A分配内存， 指针还没来得及修改， 对象B又同时使用了原来的指针来分配内存的情况。 

+ CAS 

  失败重试。

+ TLAB（Thread Local Allocation Buffer，本地线程分配缓冲）

  往线程在**Java堆**（注意还是在堆中分配）中预先分配的一小块内存中分配，是线程私有的。

  ­-XX:+/-­UseTLAB

  -­XX:TLABSize 

如果TLAB放不下，就使用CAS方式分配。

### 内存分配流程

参考java_exec_process.drawio流程图。

#### 内存分配相关优化

+ **对象逃逸分析**

  *详细参考《深入理解Java虚拟机》P11.4.3。*

  逃逸分析(Escape Analysis)是动态分析对象作用域的分析算法。若一个对象在方法中被定义后可以被其他方法引用到或被其他线程访问到，则发生逃逸。

  JDK后默认开启，-XX:+DoEscapeAnalysis。

  发生逃逸行为的情况有两种：方法逃逸和线程逃逸。

  + 方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中，return到上层方法中。
  + 线程逃逸：当一个对象在方法中定义之后，赋值给类变量或实例变量。

  如果不存在逃逸行为，则可以对该对象进行如下优化：**同步消除**、**标量替换**和**栈上分配**。

+ **栈上分配**

  > 经测试：
  >
  > 开启逃逸分析但是关闭标量替换后无论如何都会将对象分配到堆上。
  >
  > 有下面说法：
  >
  > HotSpot虚拟机只是开启逃逸分析并未使用栈上分配，也就是说栈上还是只能存基本类型数据或者引用，对象还是在堆上分配，除非使用了标量替换。可能是为了防止栈上分配的对象过多导致栈溢出。

+ **标量替换**

  通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该
  对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就
  不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认
  开启。
  
  > 标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等**基本数据类型**以及
  > **reference类型**等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。

+ **锁消除**

  没有逃逸的对象和局部变量一样是线程安全的，没必要加锁，加锁反而会带来额外浪费，编译器会移除该对象的同步锁。JDK8默认是开启锁消除的 -XX:+EliminateLocks。

#### 内存分配详情

![堆内存模型](../imgs/堆内存模型.png)

**对象在Eden区的分配：**

大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

Minor GC/Young GC：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
Major GC/Full GC：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。

Eden与Survivor区默认8:1:1，JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy。

> 经测试（ObjectAllocOnHeapTest.java）eden:from:to:parOldGen 默认并不是想象中严格的 8:1:1:20，本以为是因为+UseAdaptiveSizePolicy(默认开启)修改了，但是关闭此参数还是一样？！！是-XX:+PrintGCDetails 空间计算不准取么？

**大对象直接在老年代分配：**

注意这个大对象并不是内存占用大于Eden空间的对象，而是内存占用大于 -XX:PretenureSizeThreshold 参数指定值（单位字节）的对象。如果对象超过此参数设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。

默认使用的GC收集器是 Parallel Scanvenge 和 Parallel old。-XX:+PrintFlagsFinal 可以看到：

```txt
     bool UseParallelGC                            := true                                {product}
     bool UseParallelOldGC                          = true                                {product}
```

大对象一般是需要大量连续内存空间的对象（比如：字符串、数组、容器类）。

为了避免为大对象分配内存时的复制操作而降低效率，比如长期存活的占内存接近from/to区空间大小的很容易造成频繁的内存复制，但是可能增加FullGC次数。

> 生产环境如何协调分配各个空间大小，以及设置JVM各个参数？参考调优章节。

**对象年龄&长期存活对象移入老年代：**

年龄阈值JVM参数：-XX:MaxTenuringThreshold。默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同。

**对象动态年龄判断：**（不一定非要等到15岁，才移入老年代）

为了节省年轻代空间，希望那些可能是长期存活的对象，尽早进入老年代。所有有这么个动态年龄判断机制。

当from区一批对象的总大小大于这块区域内存大小的50%(-XX:TargetSurvivorRatio 指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接移入老年代了。比如年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把**年龄n(含)**以上的对象都放入老年代。

**老年代空间分配担保机制：**

这个“担保”是指确保新进入老年代的对象能够放下，并不是说下面对象“可进入老年代”这个许可本身。

> 这些对象包括：
>
> 1 占用空间大于 -XX:PretenureSizeThreshold 值的对象；*（会走分配担保么？估计不会，这个过程并没有MinorGC）*
>
> 2 放不下Eden区的对象（注意区分和大对象的区别）；
>
> 3 放不下Survivor的Eden区存活的对象；
>
> 4 from区动态年龄判断符合直接进入老年代的对象。

**年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间；**

如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)，就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了；

如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小；

如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾；

如果回收完还是没有足够空间存放新的对象就会发生"OOM"；

当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”。



## 对象初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。

初始化零值的内存空间是不是就是实例数据空间、对齐填充的空间需要初始化零值么？



## 设置对象头

设置这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。



## 执行`<init>`方法

执行类的构造方法。



## 参考

+ 《深入理解Java虚拟机》2.3 HotSpot虚拟机对象探秘

+ 《实战Java虚拟机：JVM故障诊断与性能优化》
+ 《揭秘Java虚拟机 JVM设计原理与实现》