# JVM对象创建＆内存分配

目标：

+ JVM对象创建详细流程
+ 对象头与指针压缩
+ 对象内存分配详情
+ 逃逸分析＆栈上分配＆标量替换



## 流程图

流程参考java_exec_process.drawio 流程图。

## 类加载检查

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个
符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。

## 分配内存

对象所需内存的大小在类加载完成后便可完全确定。

**对象的内存结构：**

Java对象的表示模型叫做“OOP-Klass”二分模型。包括两部分:

+ OOP，即Ordinary Object Point，普通对象指针。表示对象的实例信息。就是对象本身吧。

  Oop指针，这个应该不只是指对象头中的类型指针（猜测，估计指的是所有对象指针），如果系统是32G内存以下的，默认开启对象指针压缩，4个字节。

+ Klass，即Java类的C++对等体，用来描述Java类，**包含了元数据和方法信息**等，在类加载中生成存储在**方法区**。

> 这个OOP到底是什么？上面只是猜测，查下资料，最好能看看HotSpot源码。发现指针压缩不仅仅发生在对象头的类型指针，还发生在实例数据中的对象指针上。
>
> Klass和Class实例对象又是什么关系？
>
> **对象指针压缩**：
>
> 使用压缩算法将64位地址压缩为32位地址，可以减少对象内存占用，以及数据传输时带宽占用，减轻GC压力；堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间；堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，所以堆内存不要大于32G为好。

Java对象内存结构分为下面三部分：

![](../imgs/Java对象的内存结构HotSpot.png)

Markword: 32位系统占４字节，64位系统占用８字节。

> + **字节对齐**（8字节对齐）
>
>   因为底层硬件平台会要求访问时对齐（减少寻址指令周期），从而维护访问性能和正确性，这就希望字段按照大小对齐。
>
>   64位HotSpot VM每次读取数据的最小单位是**8字节**，因此对象大小必须保持8字节的整数倍，不足则填充。
>
>    JVM对其内部5中静态类型变量，oop、double、word、short和byte都有内存对齐的规则，oop引用类型按4字节对齐；double按8字节对齐；word按4字节；short按2字节，最后byte类型按1字节对齐。
>
> + **字段重排**
>
>   但是因为对齐可能会增加内存间隙（浪费内存），通过字段重排减少内存间隙；JVM 中对齐字段的顺序是 `8->4->2->1`，就是先放大的字段，再放小的字段。当8字节对齐的字段压紧后留下的空隙可以使用一个或几个更小的字段来填充。
>
>   字节对齐自然就是确保内存地址能够被其类型字节宽度所整除，JVM为了优化内存空间利用率，采用了上述的字段重排方式，将相同类型的字段组合在一起，减少一些补白操作，提升了整个空间利用率。
>
>   （注：源于网络，翻了几本书也没找到详细解释的）

**分配内存的方法：**

+ 指针碰撞（Bump the Pointer，默认使用方法）
+ 空闲列表（Free List）

择哪种分配方式由Java堆是否规整决定， 而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact） 的能力决定。 因此， 当使用Serial、 ParNew等带压缩整理过程的收集器时， 系统采用的分配算法是指针碰撞， 既简单又高效； 而当使用CMS这种基于清除（Sweep） 算法的收集器时， 理论上就只能采用较为复杂的空闲列表来分配内存。

**内存分配的并发问题解决方案：**

场景：在并发情况下也并不是线程安全的， 可能出现正在给对象A分配内存， 指针还没来得及修改， 对象B又同时使用了原来的指针来分配内存的情况。 

+ CAS 

  失败重试。

+ TLAB（Thread Local Allocation Buffer，本地线程分配缓冲）

  往线程在**Java堆**（注意还是在堆中分配）中预先分配的一小块内存中分配。

  ­-XX:+/-­UseTLAB

  -­XX:TLABSize 

如果TLAB放不下，就使用CAS方式分配。

**内存分配流程：**

参考java_exec_process.drawio流程图。

+ **对象逃逸分析**

  

## 对象初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。

初始化零值的内存空间是不是就是实例数据空间、对齐填充的空间需要初始化零值么？

## 设置对象头



## 执行`<init>`方法



## 参考

+ 《深入理解Java虚拟机》2.3 HotSpot虚拟机对象探秘

  