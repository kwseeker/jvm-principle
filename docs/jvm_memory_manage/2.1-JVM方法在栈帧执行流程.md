# JVM方法在栈帧中执行流程

以几个例子分析。

推荐使用 IDEA插件 `jclasslib`辅助分析。

## 案例1

```
// javap -c App.class
Compiled from "App.java"
public class top.kwseeker.jvm.debug.App {
  public top.kwseeker.jvm.debug.App();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public int sum(int, int);
    Code:
       0: iload_1
       1: iload_2
       2: iadd
       3: ireturn

  public int compute();
    Code:
       0: iconst_1                          // 将int类型常量1压入操作数栈, "iconst_1"是一个不可分割的指令（只是-1,0,1,2,3,4,5比较常用所以加了这样的指令）
       1: istore_1                          // 为第1个局部变量在局部变量表分配空间，将操作数(即上面的int类型值1)出栈存入第1个局部变量, istore_<n> 指将操作数栈中数存入第n个局部变量；所以a=1包含两条JVM指令
       2: iconst_2                          // 将int类型常量2压入操作数栈
       3: istore_2                          // 为第2个局部变量分配空间，将操作数(即上面的int类型值2)出栈存入第2个局部变量
       4: aload_0                           // 从局部变量0（第0个局部变量，即this）中装载引用类型值
       5: iload_1                           // 从局部变量1中装载int类型值
       6: iload_2                           // 从局部变量2中装载int类型值
       7: invokevirtual #2                  // Method sum:(II)I 调用对象的实现方法（进入到sum方法栈帧） #2 是常量池中第二个值 CONSTANT_Methodref_info
      10: bipush        100                 // 将一个8位带符号整数压入操作数栈
      12: imul                              // 操作数栈出栈两个值，执行int类型乘法
      13: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: new           #3                  // class top/kwseeker/jvm/debug/App
       3: dup
       4: invokespecial #4                  // Method "<init>":()V
       7: astore_1
       8: aload_1
       9: invokevirtual #5                  // Method compute:()I
      12: istore_2
      13: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
      16: iload_2
      17: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V
      20: return
}
```

> 关于 invokevirtual ：
>
> 字面意思是调用虚拟的，这里意思是“调用虚方法”。
>
> 方法分为“虚方法”和“非虚方法”：
>
> 非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不变的，这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
>
> 虚方法：非虚方法外其它所有体现多态特性的方法称为虚方法，比如调用可以被继承重写的（上面案例中sum()就是可以被继承重写的方法）。
>
> 方法调用JVM指令：
>
> + invokestatic
>
>   调用静态方法，解析阶段确定唯一方法版本；
>
> + invokespecial
>
>   调用<init>方法、私有方法，解析阶段确定唯一方法版本；
>
> + invokevirtual
>
>   调用虚方法（比如自己的public/protected方法，继承到的父类方法，用当前对象调用实现的接口方法）；
>
> + invokeinterface
>
>   调用接口方法（类对象强转为接口类型然后调用接口方法，SPI方式调用接口方法）；
>
> + invokedynamic：调用动态解析出需要调用的方法。
>
>   比如调用Java的函数式接口方法。



## 案例2



