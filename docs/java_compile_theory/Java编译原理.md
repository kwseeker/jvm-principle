# Java编译原理

参考: 

+ [斯坦福-编译原理](https://www.bilibili.com/video/av96207540/)

+ [编译器设计(使用教材: 编译器设计.第2版)](https://www.bilibili.com/video/BV1Bp4y1t7Cw?from=search&seid=10463750338319857506&spm_id_from=333.337.0.0)

+ 编译器设计(ENGINEERING A COMPILER).第2版

+ [700行手写编译器](https://github.com/archeryue/cpc)
+ [TinyC编译器实战](https://pandolia.net/tinyc/ch16_tinyc_compiler.html)

+ [代码与AST转换示例](https://astexplorer.net/)

+  [Java即时编译器原理解析及实践](https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html)



## 编译流程

流程图参考`drawio`文件。

### 前端编译

前端编译也有说分为下面几步的：

+ **词法、语法分析**

  JVM 对源代码的字符进行一次扫描，经过词法分析（源码`CharStream`转为Tokens），语法分析，最终生成一个抽象的语法树。语法树每一个节点都代表代码中一个语法结构，如包、类型、运算符。

+ **填充符号表**

  符号表由一组符号地址和符号信息构成，在编译不同阶段都需使用。语义分析中，符号表所登记的内容用于语义检查和生成中间代码。

  我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，JVM 会将符号替换成具体的内存地址（解析阶段，符号引用转直接引用）。

+ **注解处理**

  在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。

  JDK 1.6 之前注解是在运行期起作用，JDK 1.6提供了插入式注解处理器在编译期处理注解，相当于编译器插件，会按需修改抽象语法树，所以一旦修改了`AST`，会回到第一步重复前三步，直到注解处理不再修改`AST`。

+ **语义分析**
  语义分析（包括标注检查和数据及控制流分析、解语法糖（泛型、自动装拆箱等）等）。主要是对结构上正确的源码（语法分析阶段确认）进行上下文检查，如类型检查（比如boolean b=false;char c=2;int d=b+c就有问题了）。最终得到标注了属性的`AST`。

+ **字节码生成**
  `javac` 编译的最后阶段是字节码生成，JVM 便会根据上面几个阶段分析出来的结果（`AST`, 符号表等）转换为字节码写入磁盘，还会新增（如`clinit`和`init`（不包括已在填充符号表时已执行的默认构造方法）在这时被添加到`AST`中）和转换（如将String的加转为`StringBuilder.append`）少量代码。

### 后端编译

两种模式：

+ **Java 解释器边解释边执行**

+ **JIT将字节码转化为本地机器代码执行**

  在 HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。

  **那么 C1 编译模式和 C2 编译模式有什么区别呢？**

  C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

  简单地说 C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。

  **那么到底应该选择 C1 编译模式还是 C2 编译模式呢？**

  实际上对于 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：

  + 混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 -client 或 -server 打开即可。
  + 解释模式（Interpreted Mode）。即所有代码都解释执行，使用 -Xint 参数可以打开这个模式。
  + 编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 -Xcomp 打开这种模式。

  关于C1、C2 详细区别参考： [Java即时编译器原理解析及实践](https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html)

  **目前主要的热点代码识别方式是热点探测（Hot Spot Detection）**，有以下两种：

  + 基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。
  + 基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。

  在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。

  + 方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。

  + 回边计数器。是记录方法中的for或者while的运行次数的计数器。

  当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。
  
  如果方法是热点代码会去运行时数据区的方法区取编译好的本地代码。
  ![](/home/lee/mywork/java/java-base/jvm-principle/docs/imgs/JVM方法调用计数器触发即时编译.png)
  
  > 疑问：
  >
  > 经过JIT编译的代码存放在方法区，那未经过JIT编译的字节码代码放在哪里？
  >
  > JIT编译后的代码是什么？是机器码么？

### JIT 编译优化策略

详细参考 jvm_execution_engine/JIT编译优化.md。

+ 中间表达形式
+ 方法内联
+ 逃逸分析
+ 锁消除、锁膨胀
+ 栈上分配
+ 标量替换
+ 空值检查消除
+ 类型检测消除
+ 公共子表达式消除
+ ...

> **`AST`的作用**：
>
> 抽象语法树将代码的语义以树状结构呈现出来，方便单词或标记的定位，可用于代码检查、优化、改写，以及机器码生成。
>
> **`Antlr`是什么**：
>
> `Antlr`是可以根据输入自动生成语法树并可视化的显示出来的开源的跨语言语法分析器。
>
> AOT 编译器:
>
> 后端编译还有一种AOT编译器，程序执行前总是将代码编译成机器码，存储到本地。但是基本不会使用了。





